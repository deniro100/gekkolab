<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GekkoLab - Sensor Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 50px auto; padding: 20px; }
        .readings-container { display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 30px; }
        .reading { background: #f5f5f5; padding: 20px; border-radius: 8px; flex: 1; min-width: 150px; }
        .value { font-size: 2em; font-weight: bold; color: #333; }
        .label { color: #666; font-size: 0.9em; }
        .timestamp { color: #999; font-size: 0.8em; margin-top: 10px; }
        .error { color: red; }
        .chart-container { background: #f5f5f5; padding: 20px; border-radius: 8px; margin-top: 20px; }
        .chart-title { font-size: 1.2em; font-weight: bold; margin-bottom: 15px; color: #333; }
        canvas { max-height: 400px; }
        .section-title { font-size: 1.5em; font-weight: bold; margin-top: 40px; margin-bottom: 20px; color: #333; border-bottom: 2px solid #e74c3c; padding-bottom: 10px; }
        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .metric-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 8px; color: white; }
        .metric-card.cpu { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .metric-card.memory { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .metric-card.disk { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); }
        .metric-value { font-size: 2.5em; font-weight: bold; }
        .metric-label { font-size: 0.9em; opacity: 0.9; }
        .metric-detail { font-size: 0.8em; opacity: 0.7; margin-top: 5px; }
    </style>
</head>
<body>
<h1>GekkoLab Dashboard</h1>

<!-- System Metrics Section -->
<div class="section-title">System Metrics</div>
<div id="systemMetrics">
    <div class="metrics-grid">
        <div class="metric-card cpu">
            <div class="metric-label">CPU Usage</div>
            <div class="metric-value" id="cpuValue">--%</div>
        </div>
        <div class="metric-card memory">
            <div class="metric-label">Memory Usage</div>
            <div class="metric-value" id="memoryValue">--%</div>
            <div class="metric-detail" id="memoryDetail">-- / -- GB</div>
        </div>
        <div class="metric-card disk">
            <div class="metric-label">Disk Usage</div>
            <div class="metric-value" id="diskValue">--%</div>
            <div class="metric-detail" id="diskDetail">-- / -- GB</div>
        </div>
    </div>
</div>

<div class="chart-container">
    <div class="chart-title">CPU Usage - Real-time (Last 10 minutes, 5-second intervals)</div>
    <canvas id="cpuRealtimeChart"></canvas>
</div>

<div class="chart-container">
    <div class="chart-title">CPU Usage - Aggregated (Last 2 hours, 1-minute averages)</div>
    <canvas id="cpuAggregatedChart"></canvas>
</div>

<!-- Sensor Data Section -->
<div class="section-title">Sensor Data</div>
<div id="data">Loading...</div>

<div class="chart-container">
    <div class="chart-title">Sensor History - Last 24 Hours</div>
    <canvas id="historyChart"></canvas>
</div>

<script>
    let sensorChart = null;
    let cpuRealtimeChart = null;
    let cpuAggregatedChart = null;

    function formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }

    // ============ System Metrics Functions ============
    async function fetchSystemMetrics() {
        try {
            const response = await fetch('/api/metrics/realtime/latest');
            if (!response.ok) throw new Error('No metrics available');
            const data = await response.json();

            document.getElementById('cpuValue').textContent = data.cpuUsagePercent.toFixed(1) + '%';
            document.getElementById('memoryValue').textContent = data.memoryUsagePercent.toFixed(1) + '%';
            document.getElementById('memoryDetail').textContent = 
                formatBytes(data.memoryUsedBytes) + ' / ' + formatBytes(data.memoryTotalBytes);
            document.getElementById('diskValue').textContent = data.diskUsagePercent.toFixed(1) + '%';
            document.getElementById('diskDetail').textContent = 
                formatBytes(data.diskUsedBytes) + ' / ' + formatBytes(data.diskTotalBytes);
        } catch (err) {
            console.error('Error fetching system metrics:', err);
        }
    }

    async function fetchCpuRealtimeHistory() {
        try {
            const response = await fetch('/api/metrics/realtime/history?minutes=10');
            if (!response.ok) throw new Error('No realtime history available');
            const data = await response.json();

            if (data.length === 0) return;

            const labels = data.map(d => new Date(d.timestamp));
            const cpuData = data.map(d => d.cpuUsagePercent);

            const ctx = document.getElementById('cpuRealtimeChart').getContext('2d');

            if (cpuRealtimeChart) {
                cpuRealtimeChart.data.labels = labels;
                cpuRealtimeChart.data.datasets[0].data = cpuData;
                cpuRealtimeChart.update('none');
            } else {
                cpuRealtimeChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'CPU Usage (%)',
                            data: cpuData,
                            borderColor: '#f5576c',
                            backgroundColor: 'rgba(245, 87, 108, 0.1)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        animation: false,
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'minute',
                                    displayFormats: { minute: 'HH:mm' },
                                    tooltipFormat: 'HH:mm:ss'
                                },
                                ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 10 }
                            },
                            y: {
                                min: 0,
                                max: 100,
                                title: { display: true, text: 'CPU %' }
                            }
                        },
                        plugins: { legend: { display: false } }
                    }
                });
            }
        } catch (err) {
            console.error('Error fetching CPU realtime history:', err);
        }
    }

    async function fetchCpuAggregatedHistory() {
        try {
            const now = new Date();
            const from = new Date(now.getTime() - 2 * 60 * 60 * 1000); // 2 hours ago
            const response = await fetch(`/api/metrics/aggregated/history?from=${from.toISOString()}&to=${now.toISOString()}`);
            if (!response.ok) throw new Error('No aggregated history available');
            const data = await response.json();

            if (data.length === 0) return;

            const labels = data.map(d => new Date(d.timestamp));
            const cpuData = data.map(d => d.cpuUsagePercent);

            const ctx = document.getElementById('cpuAggregatedChart').getContext('2d');

            if (cpuAggregatedChart) {
                cpuAggregatedChart.data.labels = labels;
                cpuAggregatedChart.data.datasets[0].data = cpuData;
                cpuAggregatedChart.update('none');
            } else {
                cpuAggregatedChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'CPU Usage (1-min avg)',
                            data: cpuData,
                            borderColor: '#764ba2',
                            backgroundColor: 'rgba(118, 75, 162, 0.1)',
                            fill: true,
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'minute',
                                    displayFormats: { minute: 'HH:mm' },
                                    tooltipFormat: 'MMM d, HH:mm'
                                },
                                ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 12 }
                            },
                            y: {
                                min: 0,
                                max: 100,
                                title: { display: true, text: 'CPU % (1-min average)' }
                            }
                        },
                        plugins: { legend: { display: false } }
                    }
                });
            }
        } catch (err) {
            console.error('Error fetching CPU aggregated history:', err);
        }
    }


    // ============ Sensor Data Functions ============
    async function fetchLatest() {
        try {
            const response = await fetch('/api/sensor/latest');
            if (!response.ok) throw new Error('No data available');
            const data = await response.json();

            document.getElementById('data').innerHTML = `
                <div class="readings-container">
                    <div class="reading">
                        <div class="label">Temperature</div>
                        <div class="value">${data.temperature.toFixed(1)} °C</div>
                    </div>
                    <div class="reading">
                        <div class="label">Humidity</div>
                        <div class="value">${data.humidity.toFixed(1)} %</div>
                    </div>
                    <div class="reading">
                        <div class="label">Pressure</div>
                        <div class="value">${data.pressure.toFixed(1)} mmHg</div>
                    </div>
                </div>
                <div class="timestamp">Last updated: ${new Date(data.timestamp).toLocaleString()}</div>
            `;
        } catch (err) {
            document.getElementById('data').innerHTML = `<p class="error">${err.message}</p>`;
        }
    }

    async function fetchSensorHistory() {
        try {
            const now = new Date();
            const from = new Date(now.getTime() - 24 * 60 * 60 * 1000); // 24 hours ago
            const response = await fetch(`/api/sensor/history?from=${from.toISOString()}&to=${now.toISOString()}`);
            if (!response.ok) throw new Error('No history data available');
            const data = await response.json();

            if (data.length === 0) {
                return;
            }

            const labels = data.map(d => new Date(d.timestamp));
            const temperatures = data.map(d => d.temperature);
            const humidities = data.map(d => d.humidity);
            const pressures = data.map(d => d.pressure);

            const ctx = document.getElementById('historyChart').getContext('2d');

            if (sensorChart) {
                sensorChart.data.labels = labels;
                sensorChart.data.datasets[0].data = temperatures;
                sensorChart.data.datasets[1].data = humidities;
                sensorChart.data.datasets[2].data = pressures;
                sensorChart.update();
            } else {
                sensorChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Temperature (°C)',
                                data: temperatures,
                                borderColor: '#e74c3c',
                                backgroundColor: 'rgba(231, 76, 60, 0.1)',
                                tension: 0.3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Humidity (%)',
                                data: humidities,
                                borderColor: '#3498db',
                                backgroundColor: 'rgba(52, 152, 219, 0.1)',
                                tension: 0.3,
                                yAxisID: 'y1'
                            },
                            {
                                label: 'Pressure (mmHg)',
                                data: pressures,
                                borderColor: '#2ecc71',
                                backgroundColor: 'rgba(46, 204, 113, 0.1)',
                                tension: 0.3,
                                yAxisID: 'y2'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'hour',
                                    displayFormats: {
                                        hour: 'HH:mm'
                                    },
                                    tooltipFormat: 'MMM d, HH:mm'
                                },
                                ticks: {
                                    maxRotation: 0,
                                    autoSkip: true,
                                    maxTicksLimit: 12
                                },
                                title: {
                                    display: false
                                }
                            },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Temperature (°C)',
                                    color: '#e74c3c'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Humidity (%)',
                                    color: '#3498db'
                                },
                                grid: {
                                    drawOnChartArea: false
                                }
                            },
                            y2: {
                                type: 'linear',
                                display: false,
                                position: 'right'
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top'
                            }
                        }
                    }
                });
            }
        } catch (err) {
            console.error('Error fetching sensor history:', err);
        }
    }

    // ============ Initial Load and Refresh ============
    // Initial load
    fetchSystemMetrics();
    fetchCpuRealtimeHistory();
    fetchCpuAggregatedHistory();
    fetchLatest();
    fetchSensorHistory();

    // Refresh intervals
    setInterval(fetchSystemMetrics, 5000);      // System metrics every 5 seconds
    setInterval(fetchCpuRealtimeHistory, 5000); // CPU realtime chart every 5 seconds
    setInterval(fetchCpuAggregatedHistory, 60000); // CPU aggregated chart every minute
    setInterval(fetchLatest, 60000);            // Sensor latest every 60 seconds
    setInterval(fetchSensorHistory, 60000);     // Sensor history every 60 seconds
</script>
</body>
</html>
